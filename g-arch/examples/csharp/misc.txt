using System.Collections.Generic;

namespace GArch_CSharp_Example
{
    public enum SystemState : byte
    {
        Off,
        On
    }

    public interface IReadOnlyGameState
    {
        #region Data

        float Delta { get; }
        ulong Frame { get; }

        #endregion Data

        #region Families

        IReadOnlyCollection&ltKeyValuePair&ltint, IControllable&gt&gt Controllables { get; }
        IReadOnlyCollection&ltKeyValuePair&ltint, IDrawable&gt&gt Drawables { get; }
        IReadOnlyCollection&ltKeyValuePair&ltint, IMovable&gt&gt Movables { get; }
        IReadOnlyCollection&ltKeyValuePair&ltint, Player&gt&gt Players { get; }

        #endregion Families

        #region System States

        SystemState ControlPlayerState { get; }
        SystemState DrawPlayerState { get; }
        SystemState MovePlayerState { get; }

        #endregion System States
    }

    public class GameState : IReadOnlyGameState
    {
        #region Data

        private readonly Dictionary&ltint, IControllable&gt controllables = new Dictionary&ltint, IControllable&gt();
        private readonly Dictionary&ltint, IDrawable&gt drawables = new Dictionary&ltint, IDrawable&gt();
        private readonly Dictionary&ltint, IMovable&gt movables = new Dictionary&ltint, IMovable&gt();
        private readonly Dictionary&ltint, Player&gt players = new Dictionary&ltint, Player&gt();

        #endregion Data

        #region IReadOnlyGameState

        #region Data

        public float Delta { get; set; }

        public ulong Frame { get; set; }

        #endregion Data

        #region Families

        public IReadOnlyCollection&ltKeyValuePair&ltint, IControllable&gt&gt Controllables =&gt controllables;
        public IReadOnlyCollection&ltKeyValuePair&ltint, IDrawable&gt&gt Drawables =&gt drawables;

        public IReadOnlyCollection&ltKeyValuePair&ltint, IMovable&gt&gt Movables =&gt movables;
        public IReadOnlyCollection&ltKeyValuePair&ltint, Player&gt&gt Players =&gt players;

        #endregion Families

        #region System State
        public SystemState MovePlayerState { get; private set; }
        public SystemState DrawPlayerState { get; private set; }
        public SystemState ControlPlayerState { get; private set; }

        #endregion System State

        #endregion IReadOnlyGameState

        private void AddPlayer(Player player)
        {
            var code = player.GetHashCode();
            players.Add(code, player);
            movables.Add(code, player);
            drawables.Add(code, player);
            controllables.Add(code, player);
        }

        public void AddModifications(GameStateModification gameStateModification)
        {
            foreach (var player in gameStateModification.PlayersToAdd)
            {
                AddPlayer(player);
            }
            foreach (var playerToRemove in gameStateModification.PlayersToRemove)
            {
                RemovePlayer(playerToRemove);
            }
            foreach (var (index, position) in gameStateModification.PositionChanges)
            {
                if (players.TryGetValue(index, out var player))
                {
                    player.position = position;
                    break;
                }
            }
            MovePlayerState = gameStateModification.newMovePlayerState;
            DrawPlayerState = gameStateModification.newDrawPlayerState;
            ControlPlayerState = gameStateModification.newControlPlayerState;
        }

        private void RemovePlayer(int code)
        {
            players.Remove(code);
            movables.Remove(code);
            drawables.Remove(code);
            controllables.Remove(code);
        }
    }

    public class GameStateModification
    {
        #region Entity Changes

        private readonly List&ltPlayer&gt playersToAdd = new List&ltPlayer&gt();
        private readonly List&ltint&gt playersToRemove = new List&ltint&gt();

        public IEnumerable&ltPlayer&gt PlayersToAdd =&gt playersToAdd;
        public IEnumerable&ltint&gt PlayersToRemove =&gt playersToRemove;

        #endregion Entity Changes

        #region Component Changes

        private readonly List&ltKeyValuePair&ltint, Controller&gt&gt controllerChanges = new List&ltKeyValuePair&ltint, Controller&gt&gt();

        private readonly List&ltKeyValuePair&ltint, Position&gt&gt positionChanges = new List&ltKeyValuePair&ltint, Position&gt&gt();

        private readonly List&ltKeyValuePair&ltint, Texture&gt&gt textureChanges = new List&ltKeyValuePair&ltint, Texture&gt&gt();

        private readonly List&ltKeyValuePair&ltint, Velocity&gt&gt velocityChanges = new List&ltKeyValuePair&ltint, Velocity&gt&gt();

        public IEnumerable&ltKeyValuePair&ltint, Controller&gt&gt ControllerChanges =&gt controllerChanges;
        public IEnumerable&ltKeyValuePair&ltint, Position&gt&gt PositionChanges =&gt positionChanges;
        public IEnumerable&ltKeyValuePair&ltint, Texture&gt&gt TextureChanges =&gt textureChanges;
        public IEnumerable&ltKeyValuePair&ltint, Velocity&gt&gt VelocityChanges =&gt velocityChanges;

        #endregion Component Changes

        public SystemState newMovePlayerState, newDrawPlayerState, newControlPlayerState;

        internal void Reset()
        {
            playersToAdd.Clear();
            playersToRemove.Clear();

            controllerChanges.Clear();
            positionChanges.Clear();
            textureChanges.Clear();
            velocityChanges.Clear();
        }
    }

    internal static class Extensions
    {
        public static void Deconstruct&ltT1, T2&gt(this KeyValuePair&ltT1, T2&gt pair, out T1 key, out T2 value)
        {
            key = pair.Key;
            value = pair.Value;
        }
    }
}